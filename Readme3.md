Алгоритмы сортировки и поиска
Сортировка выбором (Selection Sort)
Это простой метод сортировки, при котором массив постепенно разделяется на отсортированную и неотсортированную части.
Принцип работы: на каждом шаге ищется минимальный элемент из неотсортированной области и меняется местами с первым элементом этой области, тем самым «перемещаясь» в конец отсортированной части.
Сложность: O(n²) во всех случаях, поскольку выполняется примерно n²/2 сравнений и n обменов.
Пример:
Исходный массив: [64, 25, 12, 22, 11]
Результат: [11, 12, 22, 25, 64]
Сортировка пузырьком (Bubble Sort)
Простая сортировка, основанная на попарном сравнении соседних элементов и их обмене, если они стоят в неправильном порядке.
Процесс: массив проходит несколько итераций; если за один проход не было обменов, сортировка завершается.
Сложность: O(n²) в худшем случае; с оптимизацией (при проверке обменов) — O(n) в лучшем.
Пример:
Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Результат: [11, 12, 22, 25, 34, 64, 90]
Сортировка вставками (Insertion Sort)
Алгоритм формирует отсортированную часть массива, последовательно вставляя каждый новый элемент в нужное место.
Ход работы: начиная со второго элемента, каждый следующий сравнивается с предыдущими и вставляется туда, где он должен находиться.
Сложность: O(n²) в худшем случае, O(n) в лучшем (при почти отсортированных данных).
Пример:
Исходный массив: [12, 11, 13, 5, 6]
Результат: [5, 6, 11, 12, 13]
Сортировка слиянием (Merge Sort)
Рекурсивный алгоритм по принципу «разделяй и властвуй».
Описание: массив делится пополам, каждая часть сортируется отдельно, затем отсортированные части объединяются.
Сложность: O(n log n). Требуется дополнительная память для объединения.
Пример:
Исходный массив: [38, 27, 43, 3, 9, 82, 10]
Результат: [3, 9, 10, 27, 38, 43, 82]
Сортировка Шелла (Shell Sort)
Обобщение сортировки вставками, использующее «шаг» между сравниваемыми элементами.
Идея: сначала элементы сортируются на большом расстоянии друг от друга, а затем шаг постепенно уменьшается до 1.
Сложность: в среднем O(n¹·⁵), зависит от выбора последовательности шагов.
Пример:
Исходный массив: [23, 12, 1, 8, 34, 54, 2, 3]
Результат: [1, 2, 3, 8, 12, 23, 34, 54]
Быстрая сортировка (Quick Sort)
Один из самых популярных и эффективных алгоритмов. Основан на принципе «разделяй и властвуй».
Описание: выбирается опорный элемент, массив делится на две части — меньшие и большие опорного, затем обе части сортируются рекурсивно.
Сложность: O(n log n) в среднем, O(n²) — в худшем случае (например, при уже отсортированных данных).
Пример:
Исходный массив: [10, 7, 8, 9, 1, 5]
Результат: [1, 5, 7, 8, 9, 10]
Пирамидальная сортировка (Heap Sort)
Основана на структуре данных «куча» (heap).
Принцип: из массива сначала строится max-heap (двоичная куча), затем наибольший элемент извлекается и помещается в конец массива.
Сложность: O(n log n) — для всех случаев. Построение кучи — O(n), каждое извлечение — O(log n).
Пример:
Исходный массив: [12, 11, 13, 5, 6, 7]
Результат: [5, 6, 7, 11, 12, 13]
Последовательный (линейный) поиск (Linear Search)
Простой способ поиска, при котором элементы массива проверяются один за другим.
Описание: каждый элемент сравнивается с искомым; если найдено совпадение, возвращается индекс, иначе — -1.
Сложность: O(n).
Пример:
Исходный массив: [4, 2, 7, 1, 9]
Результат: элемент 7 найден на позиции 2.
Бинарный поиск (Binary Search)
Метод поиска элемента в отсортированном массиве путём деления его пополам.
Ход работы: проверяется средний элемент; если он равен цели — поиск окончен, если меньше — поиск продолжается в правой части, если больше — в левой.
Сложность: O(log n).
Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат: элемент найден на позиции 5.
Интерполяционный поиск (Interpolation Search)
Улучшенная версия бинарного поиска, использующая значение искомого элемента для оценки его позиции.
Описание: предполагает равномерное распределение данных и вычисляет точку поиска не посредине, а пропорционально диапазону значений.
Сложность: в среднем O(log log n), в худшем — O(n).
Пример:
Исходный массив: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат: элемент найден на позиции 5.
Поиск по Фибоначчи (Fibonacci Search)
Модификация бинарного поиска, в которой массив делится не пополам, а в соответствии с числами Фибоначчи.
Описание: выбирается число Фибоначчи, большее длины массива, после чего поиск выполняется с делением массива на части, соответствующие соседним числам Фибоначчи.
Сложность: O(log n) в среднем, O(n) — в худшем.
Пример:
Исходный массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Результат: элемент найден на позиции 8.
