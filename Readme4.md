вариант 5
алгоритм:
def count_vowels(s):
    if not s:  # базовый случай
        return 0
    vowels = "аеёиоуыэюя"
    return (1 if s[0].lower() in vowels else 0) + count_vowels(s[1:])

# Пример использования
text = "Привет, как дела?"
print("Количество гласных:", count_vowels(text))

пример ввода Привет, как дела?
пример вывода Количество гласных: 5

объяснение алгоритма:
1.def count_vowels(s): — объявляем функцию count_vowels, принимающую строку s.
2.if not s: — проверяем, пустая ли строка. Это условие базового случая рекурсии.
3.return 0 — если строка пустая, нет символов — возвращаем 0 гласных.
4.vowels = "аеёиоуыэюя" — задаём строку, содержащую все гласные (англ. + рус.).
5.return (1 if s[0].lower() in vowels else 0) + count_vowels(s[1:]) — берём первый символ s[0], приводим к нижнему регистру и проверяем, гласный ли он; если да — считаем 1, иначе 0. К этому добавляем результат рекурсивного вызова для оставшейся части строки s[1:].

Временная сложность:
O(n), где n — длина строки.

Объяснение временной сложности:
Функция обрабатывает каждый символ один раз, выполняя для него:
проверку, является ли он гласным (O(1)),
вызов рекурсии на следующем символе.
Всего выполняется n таких шагов, поэтому общее время — линейное: O(n).
Дополнительно — из-за рекурсивных вызовов создаётся стек вызовов глубиной n,
поэтому пространственная сложность тоже O(n).

ответ на вопрос номер 6:

«Разделяй и властвуй» — это один из самых важных подходов в построении эффективных алгоритмов.
Он основан на идее: сложную задачу можно решить, если разбить её на несколько более простых, решить каждую из них отдельно и потом объединить результаты.
Три основных шага стратегии

Разделение (Divide)
Исходная задача разбивается на несколько подзадач, похожих на исходную, но меньшего размера.
Например, массив делится на две половины.

Властвование (Conquer)
Каждая подзадача решается отдельно.
Часто для этого используется рекурсия, пока задачи не станут достаточно простыми (например, длина массива = 1).

Объединение (Combine)
Результаты подзадач объединяются, чтобы получить итоговое решение для всей задачи.
Например, после сортировки двух половин мы объединяем их в один отсортированный массив.

Пример: сортировка слиянием (Merge Sort)
Рассмотрим, как работает стратегия «разделяй и властвуй» на примере сортировки слиянием.
Разделение
Массив, например [8, 3, 5, 2, 9, 1], делим пополам:
левая часть: [8, 3, 5]
правая часть: [2, 9, 1]
Затем каждую часть снова делим, пока не останется по одному элементу:
[8, 3, 5, 2, 9, 1]
→ [8, 3, 5] и [2, 9, 1]
→ [8], [3, 5], [2], [9, 1]
→ [8], [3], [5], [2], [9], [1]

Властвование (рекурсивное решение)
Когда остаётся один элемент — он уже считается отсортированным.
Теперь начинается этап объединения.

Объединение (слияние)
Мы берём два отсортированных списка и сливаем их в один, сохраняя порядок:
[3] и [5] → [3, 5]
[9] и [1] → [1, 9]
[8] и [3, 5] → [3, 5, 8]
[2] и [1, 9] → [1, 2, 9]
наконец [3, 5, 8] и [1, 2, 9] → [1, 2, 3, 5, 8, 9]

Временная сложность

Каждый уровень рекурсии обрабатывает все элементы массива (O(n));
Число уровней ≈ log₂(n) (потому что каждый раз делим массив пополам).

Итого:
T(n)=O(nlogn)
